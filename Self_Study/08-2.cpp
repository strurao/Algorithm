/*
DP

1로 만들기

그리디 파트에서 1로 만드는 문제와 다르다!

`d[i] = d[i - 1] + 1;` 이 부분에서 +1을 해주는 이유는 숫자 `i`를 1로 만드는데 필요한 최소 연산 횟수를 계산하는 과정에서, 
현재 숫자 `i`에서 1을 빼는 연산을 한 번 수행하면 연산 횟수가 1회 증가하기 때문입니다.
숫자 `i`를 1로 만들기 위해 이전 숫자 `i - 1`을 이용하는 경우, 다음과 같이 생각할 수 있습니다. 
이전 숫자인 `i - 1`을 1로 만드는데 필요한 최소 연산 횟수는 이미 `d[i - 1]`에 저장되어 있습니다. 
따라서 이전 숫자를 1로 만드는데 필요한 연산 횟수에 1을 더해주면 현재 숫자 `i`를 1로 만드는데 필요한 최소 연산 횟수를 계산할 수 있습니다.
이 과정은 숫자를 줄여나가면서 1로 만들어가는 과정을 모방한 것으로, 
이전 숫자를 1로 만드는데 필요한 최소 연산 횟수에 1을 더하는 것은 현재 숫자에서 1을 빼는 연산을 수행하는 것과 동일한 효과를 가지게 됩니다. 
이렇게 함으로써 모든 가능한 연산 중에서 가장 작은 연산 횟수를 선택하여 `d[i]`에 저장하게 됩니다.
*/

#include <bits/stdc++.h>
using namespace std;

// 앞서 계산된 결과를 저장하기 위한 DP테이블 초기화
int d[30001]; // d[i]의 값은 숫자 i를 1로 만드는데 필요한 최소 연산 횟수를 나타낸다
int x;

int main()
{
	cin >> x;
	// dp 진행 - 보텀업
	for (int i = 2; i <= x; i++)
	{
		// 현재의 수에서 1을 빼는 경우
		d[i] = d[i - 1] + 1; // 끝에 1을 더해주는 이유는 함수의 호출 횟수를 구해야 하므로
		
		// 현재의 수가 2로 나누어 떨어지는 경우
		if (i % 2 == 0)
			d[i] = min(d[i], d[i / 2] + 1);
		// 현재의 수가 3으로 나누어 떨어지는 경우
		if (i % 3 == 0)
			d[i] = min(d[i], d[i / 3] + 1);
		// 현재의 수가 5으로 나누어 떨어지는 경우
		if (i % 5 == 0)
			d[i] = min(d[i], d[i / 5] + 1);
	}
	cout << d[x] << '\n';
	return 0;
}