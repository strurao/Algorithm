/*
그리디

모험가 길드 문제

앞에서부터 공포도를 하나씩 확인하며 '현재 그룹에 포함된 모험가의 수'가 '현재 확인하고 있는 공포도' 보다 크거나 같다면 이를 그룹으로 설정하면 된다
이러한 방법을 이용하면 공포도가 오름차순으로 정렬되어 있다는 점에서, 항상 최소한의 모험가의 수만 포함하여 그룹을 결성하게 된다.
이는 문제에서 요하는 그룹 수의 최댓값을 구하는 것에 알맞는 풀이법이다.
*/

#include <bits/stdc++.h>
using namespace std;

int n; // 입력으로 주어질 모험가 N명
vector<int> arr;

int main()
{
	cin >> n;

	for (int i = 0; i < n; i++)
	{
		int x;
		cin >> x; // 입력으로 주어질 각 모험가의 공포도
		arr.push_back(x);
	}

	sort(arr.begin(), arr.end()); // 정렬

	int result = 0; // 총 그룹의 수
	int count = 0; // 현재 그룹에 포함된 모험가의 수

	for (int i = 0; i < n; i++) // 공포도를 낮은 것부터 하나씩 확인
	{
		count += 1; // 현재 그룹에 해당 모험가를 포함시키기
		if (count >= arr[i]) // 현재 그룹에 포함된 모험가의 수가 현재의 공포도 이상이라면 
		{
			// 그룹 결성
			result += 1; // 총 그룹 수 증가

			count = 0; // 현재 그룹에 포함된 모험가의 수 초기화
		}
	}
	cout << result << '\n'; // 총 그룹 수 출력
	
}
