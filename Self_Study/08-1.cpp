/*
DP 
*/
#include <bits/stdc++.h>
using namespace std;


/* 피보나치 수열 - 비효율적인 버전 - 시간복잡도가 O(N) */

// 재귀함수로 구현
int fibo(int x) {
    if (x == 1 || x == 2) {
        return 1;
    }
    return fibo(x - 1) + fibo(x - 2);
}

int main(void) {
    cout << fibo(4) << '\n';
}


////////////////////////////////////////////////


/* 피보나치 수열 (Top-bottom) : 
큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 탑다운 방식이라고 말한다. '하향식'이라고도 한다 
메모이제이션은 탑다운 방식에 국한되어 사용되는 표현이다. 
엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미하므로, 다이나믹 프로그래밍과는 별도의 개념이다.
한 번 계산된 결과를 어딘가에 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있다.
수열은 배열로 표현할 수 있는데, 메모이제이션은 때에 따라서 다른 자료형, 예를 들어 사전(dict)자료형을 이용할 수도 있다. 
사전 자료형은 수열처럼 연속적이지 않은 경우에 유용하다.
*/
// 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 배열 초기화
long long d[100];

// 피보나치 함수(Fibonacci Function)를 재귀함수로 구현 (탑다운 다이나믹 프로그래밍)
long long fibo2(int x) {
    // 종료 조건(1 혹은 2일 때 1을 반환)
    if (x == 1 || x == 2) {
        return 1;
    }
    // 이미 계산한 적 있는 문제라면 그대로 반환
    if (d[x] != 0) {
        return d[x];
    }
    // 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo2(x - 1) + fibo2(x - 2);
    return d[x];
}

int main(void) {
    cout << fibo2(50) << '\n';
}


////////////////////////////////////////////////


/* 피보나치 수열 (Bottom-top) : 
단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 보텀업 방식이라고 한다. 
상향식이라고도한다.
다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식이다.
보텀업 방식에서 사용되는 결과 저장용 리스트는 DP테이블 이라고 부르며, 메모이제이션은 탑다운 방식에 국한되어 사용되는 표현이다. 
가능하다면 재귀 함수를 이용하는 탑다운 방식보다는 보텀업 방식으로 구현하는 것이 권장된다.
시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있다.  또한 재귀 함수를 사용하면 컴퓨터 시스템에서는 
함수를 다시 호출했을 때 메모리 상에 적재되는 일련의 과정을 따라야 하므로 오버헤드가 발생할 수 있다. 
따라서 재귀 함수 대신에 반복문을 사용하여 오버헤드를 줄일 수 있다. 성능이 좋다.
*/
// 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
long long d[100];

int main(void) {
    // 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
    d[1] = 1;
    d[2] = 1;
    int n = 50; // 50번째 피보나치 수를 계산

    // 피보나치 함수(Fibonacci Function) 반복문으로 구현(보텀업 다이나믹 프로그래밍)
    for (int i = 3; i <= n; i++) {
        d[i] = d[i - 1] + d[i - 2];
    }
    cout << d[n] << '\n';
}