[강의 링크](https://youtu.be/cswJ1h-How0?si=uRV2mZUgNe25Yk7z)

>  <u>리스트에 순차적으로 접근해야 할 때 두 개의 점의 위치를 기록하면서 처리</u>하는 알고리즘이다.

흔히 2, 3, 4, 5, 6, 7 번 학생을 지목해야 할 때 간단히 '2번부터 7번까지의 학생' 이라고 부르곤 합니다. 
리스트에 담긴 데이터에 순차적으로 접근해야 할 때는 **시작점**과 **끝점** 2개의 점으로 접근할 데이터의 범위를 표현할 수 있다.

투 포인터 알고리즘은 주로 두 요소의 조합을 찾거나 조건을 만족하는 연속적인 부분 배열을 찾을 때 사용되며, 
배열이나 리스트가 **정렬**되어 있거나, 특정 조건을 만족하는 경우에 유용합니다. 

투 포인터 알고리즘은 **동적**인 상황, 즉 배열의 요소들이 변경되거나 추가되는 경우에도 효과적으로 적용할 수 있습니다. 
- 참고로 Prefix Sum은 정적인 배열, 즉 배열의 요소가 변경되지 않고 여러 쿼리를 빠르게 처리해야 할 때 더 유용합니다.

투 포인터 알고리즘은 양 끝점 또는 두 포인터가 만나거나 범위를 충족시킬 때까지만 순회하므로 
⏰ `O(n)` 시간 안에 해결할 수 있는 문제에 적합합니다. 

```cpp
#include <bits/stdc++.h>
using namespace std;

int n = 5; // 데이터의 개수 N
int m = 5; // 찾고자 하는 부분합 M
int arr[] = {1, 2, 3, 2, 5}; // 전체 수열

int main() {
    int cnt = 0;
    int intervalSum = 0;
    int end = 0;

    // start를 오른쪽으로 한칸씩 차례대로 증가시키며 반복
    for (int start = 0; start < n; start++) {
        // end를 가능한 만큼 오른쪽으로 이동시키기, 데이터 범위 벗어나지 않도록
        while (intervalSum < m && end < n) {
            intervalSum += arr[end];
            end += 1;
        }
        // 부분합이 m일 때 카운트 증가
        if (intervalSum == m) {
            cnt += 1;
        }
        intervalSum -= arr[start];
    }

    cout << cnt << '\n';
}
