## 입출력 관련 메모

추후 출력이 매우 많은 문제같은 경우 ``endl`` 보다 ``\n``이 훨씬 빠르다.

``endl`` 의 경우 해당 키워드가 나올 때마다 ``출력 버퍼(buffer)``를 비워주게 되는데``(flush)`` 이 과정이 생각보다 시간을 잡아먹는다. 

그렇기 때문에 ``endl`` 보다는 ``\n``으로 출력버퍼에 계속 쌓아주면서 나중에 한번에 비워주는게 좋다.

쉽게 생각해서 매 번 쓰레기통 안에 있는 쓰레기를 비워주는 것 보다 어느정도 모아두었다가 나중에 한 번에 비워주는게 효율적인 것과 비슷한 원리라고 보면 된다. [참고한 블로그 1](https://st-lab.tistory.com/202)
[참고한 블로그 2](https://st-lab.tistory.com/232)

``ios_base::sync_with_stdio(false);``와 ``cin.tie(0);``는 C++의 입출력 성능을 향상시키기 위해 사용되는 코드이다.

C++의 ``iostream 라이브러리``는 C 스타일의 입출력 함수``(printf, scanf)``보다 느린 속도로 동작할 수 있다. 

이는 **C++의 입출력 스트림과 C 표준 입출력 버퍼 사이에 동기화 작업을 수행**하기 때문이다. 

기본적으로 C++ 표준스트림은 C 표준 스트림과 동기화가 되어있기 때문에 이를 끊어주는 것이 좋다.
하지만, 많은 경우에는 이러한 동기화 작업이 필요하지 않고, 속도가 중요한 상황에서는 성능 저하를 가져올 수 있다. 
따라서, ``ios_base::sync_with_stdio(false);``를 호출하여 C++의 입출력 스트림과 C 표준 입출력 버퍼 간의 동기화를 **해제**할 수 있다. 즉, ``sync_with_stdio()``에 false 로 인자를 넘겨 두 스트림의 동기화를 끊어주는 것이다.
이렇게 하면 입력 및 출력 작업이 좀 더 빠르게 처리될 수 있다.

또한, ``cin.tie(0);``은 ``cin 객체``와 ``cout 객체``를 연결하는 연산자 결합도를 해제하는 역할을 한다. 
기본적으로 ``cin.tie(&cout)``로 설정되어 있어서 ``입력 작업(cin)``과 ``출력 작업(cout)``이 서로 연결되어 있는데, 
이로 인해 출력 버퍼가 비워질 때마다 입력 버퍼도 함께 비워지게 된다. 
그러나 실제로 입력과 출력이 병렬적으로 진행되지 않아야 하는 경우에는 연결을 해제하여 성능 향상을 기대할 수 있다.

어떤 경우에는 왜 ``cin.tie(NULL)`` 이나 ``cout.tie(NULL)`` 을 사용하지 않냐고 질문이 올 수 있다.

하지만 잘 생각해보면, ``tie()``는 '입력과 출력' 연결을 끊어주는 것이다.

쉽게 말하자면 ``cin`` 입력이 들어오면 자동적으로 출력 버퍼를 비우게 된다는 것이다.

즉, 입출력이 반복적으로 있을 때엔 위 연결을 끊어주는 것이 맞지만, 이 문제에서는 처음 입력이 들어오고 이 후 출력만 존재한다.

입력과 출력이 번갈아가면서 사용하는 것이 아니기 때문에 서로 연결을 끊어주어도 의미가 없다. 즉 쓸 필요가 없다는 뜻이다.
