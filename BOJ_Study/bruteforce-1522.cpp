#include <iostream>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);  // C++의 입출력 버퍼를 C 표준 입출력과 동기화하지 않음
    cin.tie(NULL);  // cin과 cout의 묶음 해제
    cout.tie(NULL); // cout의 묶음 해제

    string s;
    cin >> s;  // 문자열 입력

    int a = 0, ans = s.size();  // 'a'의 개수를 저장하는 변수 a, 최종 답을 저장하는 변수 ans

    for (auto c : s)
        if (c == 'a') a++;  // 입력 문자열을 순회하며 'a'의 개수를 계산 ... 이 문제에서는 문자열의 끝과 처음이 연결되어 있다고 가정한다

    /*
    문자열 내의 모든 위치에서 시작하여 윈도우를 원형으로 슬라이딩한다.이 때, 윈도우 크기는 원본 문자열의 길이와 같다
    윈도우 크기를 원본 문자열의 길이와 같게 설정하는 이유는 원형 문자열에서 모든 가능한 시작 위치에 대해 모든 문자열을 한 번씩 탐색하기 위함
    */
    for (int i = 0; i < s.size(); i++)
    {
        int cnt = a, temp = 0;  // cnt: 한 곳으로 몰아 넣어야 하는 'a'의 개수, temp: 자리를 바꿔야 할 'b'의 개수

        // 슬라이딩 윈도우 기법 활용하여 원형으로 문자열을 탐색
        for (int j = i; j < i + s.size(); j++)
        {
            if (cnt == 0)
                break;  // 'a'를 모두 배치했으면 탐색 종료

            // 윈도우를 슬라이딩하면서 cnt를 감소시키고, 만약 현재 위치에 있는 문자가 'b'라면 temp를 증가
            if (s[j % s.size()] == 'b') // 'j % s.size()'는 현재 슬라이딩 윈도우의 위치
                temp++, cnt--;  // 'b'를 'a'로 바꾸어야 하므로 temp 증가, cnt 감소
            else // 'a'라면 
                cnt--;  // 'a'를 사용했으므로 cnt 감소
        }

        ans = min(ans, temp);  // 각 윈도우에서 'b'를 'a'로 바꾸는데 필요한 개수인 temp를 계산하고, 이 값을 ans와 비교하여 최소값을 유지
        // 모든 시작 위치에 대해 위 과정을 반복하며 최종적으로 ans에는 'a'를 모두 배치하기 위해 바꿔야 할 'b'의 최소 개수가 저장된다
    }

    cout << ans << '\n';  // 결과 출력
    return 0;
}

/*
풀이 참고 https://astrid-dm.tistory.com/455

슬라이딩 윈도우 참고
- https://ansohxxn.github.io/algorithm/twopointer/
- https://kimmeh1.tistory.com/507
- https://ji-musclecode.tistory.com/37





슬라이딩 윈도우는 어떠한 배열에서 일정 범위의 값을 비교할 때 유용하게 사용될 수 있는 방법이다. 
또한 어떠한 배열에서 고정된 크기의 범위를 탐색할 때 유용하게 사용된다.
교집합의 정보를 공유하고, 차이가 나는 양쪽 끝 원소만 갱신하는 방법이다.

투 포인터와 비슷하다고 생각할 수 있지만 투 포인터는 정렬된 배열 내에서 가변적인 범위를 탐색하는 반면 
슬라이딩 윈도우는 정렬의 유무와 상관없이 고정적인 범위를 탐색한다는 것에 차이가 있다.





윈도우 크기를 원본 문자열의 길이와 같게 설정하는 이유는 원형 문자열에서 모든 가능한 시작 위치에 대해 모든 문자열을 한 번씩 탐색하기 위함입니다.

예를 들어, 주어진 문자열이 "abab"라고 가정해보겠습니다. 이 문자열을 원형으로 생각하면 "ababab"가 됩니다. 
이 때, 슬라이딩 윈도우의 크기를 원본 문자열의 길이인 4로 설정하면, 시작 위치가 어디든 간에 모든 가능한 부분 문자열을 한 번씩 탐색할 수 있습니다.

슬라이딩 윈도우의 크기를 원본 문자열의 길이와 같게 설정하는 것은 원형 문자열에서 모든 부분 문자열을 고려하기 위한 전략입니다. 
이렇게 하면 문자열의 시작 위치에 따라 중복되는 탐색을 줄일 수 있고, 모든 가능한 경우에 대해 탐색할 수 있습니다.




`if (s[j % s.size()] == 'b')` 이 코드는 슬라이딩 윈도우를 이용하여 원형 문자열을 탐색하는 과정에서 사용되는 부분입니다.
여기서 `j % s.size()`는 현재 슬라이딩 윈도우의 위치를 나타냅니다. 

`%` 연산자는 나머지를 계산하는 연산으로, `j`를 `s.size()`로 나눈 나머지는 항상 `0`부터 `s.size() - 1` 사이의 값을 가지게 됩니다.

원형 문자열을 생각할 때, 문자열의 끝과 시작이 연결되어 있으므로 슬라이딩 윈도우를 움직일 때에도 인덱스가 문자열의 길이를 넘어가는 경우가 발생할 수 있습니다. 
따라서 `%` 연산자를 사용하여 원형 문자열 내에서 인덱스를 순환시키는 것이 중요합니다.

즉, `s[j % s.size()]`는 현재 슬라이딩 윈도우의 위치에 있는 문자를 나타냅니다. 
이 위치의 문자가 'b'인지 확인하여 'b'를 'a'로 바꾸어야 하는지를 판단하고 그에 따라 `temp`와 `cnt` 값을 업데이트합니다.

이 코드를 사용하는 이유는 원형 문자열에서 슬라이딩 윈도우를 통해 문자열을 탐색할 때, 문자열의 끝과 시작을 연결시켜야 하기 때문입니다. 
이렇게 하면 문자열을 순환하면서 탐색할 수 있으며, 슬라이딩 윈도우를 이동하면서 원형 문자열을 효과적으로 탐색할 수 있습니다.
*/