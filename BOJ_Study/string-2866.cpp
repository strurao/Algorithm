/*
해당 문제는 이분 탐색을 이용하여 주어진 문자열 행렬에서 중복이 발생하는 최소 행을 찾는 문제이다.

문제 이해 참고
- https://pangseyoung.tistory.com/entry/%EB%B0%B1%EC%A4%80-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%9E%98%EB%9D%BC%EB%82%B4%EA%B8%B0-2866

풀이 참고
- https://velog.io/@soosungp33/BOJ-2866%EB%B2%88-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%9E%98%EB%9D%BC%EB%82%B4%EA%B8%B0C

*/

#include <iostream>
#include <algorithm>
#include <set>

using namespace std;

int r, c; // 행 R, 열 C
string arr[1001]; // 2 ≤ R, C ≤ 1000)

int main() 
{
    ios_base::sync_with_stdio(false); // C++의 입출력 스트림과 C 표준 입출력 버퍼 간의 동기화를 해제
    cin.tie(0); //  cin 객체와 cout 객체의  tie를 끊어준다. 이로 인해 입력과 출력이 번갈아 등장할 때 마다 버퍼를 비우는 작업을 생략할 수 있다

    cin >> r >> c;
    for (int i = 1; i <= r; i++) 
    {
        cin >> arr[i]; // 각각의 행에 대한 문자열을 입력 받습니다.
    }

    // 열 개수를 fix 하고 행 인덱스(r)를 옮기며 이분탐색한다
    
    // 1. start = 1 , end = r로 설정해준다
    int start = 1, end = r; // 이분 탐색을 위한 시작점(start)와 끝점(end) 설정
    while (start <= end) 
    {
        int mid = (start + end) / 2; // 중간값 계산
        
        set<string> s;
        /* 
        set은 C++ 표준 라이브러리의 컨테이너 중 하나로, 중복된 원소를 가질 수 없는 컨테이너입니다.
        set의 각 원소는 고유해야 하며, 이는 자동으로 정렬되어 저장됩니다.
        */ 
        bool check = true;

        // 2. mid번째 행부터 끝까지 문자열에 중복이 있는지 검사한다
        for (int i = 0; i < c; i++) 
        {
            string tmp = "";

            for (int j = mid; j <= r; j++) 
            {
                tmp += arr[j][i]; // mid번째부터 마지막까지 모든 문자열들을 합침
            }

            if (s.find(tmp) == s.end()) 
            {
                s.insert(tmp); // 만약 현재 생성된 문자열 tmp가 set에 없다면 추가함
            }

            else 
            {
                check = false;
                break;
                /* 만약 현재 생성된 문자열 tmp가 이미 set에 있다면 중복이 있는 것으로 판단하고,
                   체크 변수(check)를 false로 설정하고 반복문에서 나옵니다 */
            }
        }

        // 3. 범위 설정

        if (check) 
        {
            // 3-1. 중복이 없으면 행을 삭제하고 내려가야하므로 start = mid + 1
            start = mid + 1;
        }
        else 
        {
            // 3-2. 중복이 있으면 mid보다 작은 행부터 시작했을 때도 중복이 있을 수 있으므로 end = mid -1
            end = mid - 1;
        }
    }
    /*
    4.
    탐색이 종료되었을 때 start는 중복이 있는 행인데 count는 삭제된 행의 개수이므로
    중복이 있기 전 행과 삭제된 행까지만 계산해야되서 -2를 해주면 된다
    */
    cout << start - 2;
}



/*
위 코드에서 set은 주어진 문자열 행렬에서 각 열을 기준으로 생성된 문자열들이 중복되는지 여부를 판단하는데 사용됩니다.

각 열에 대해 mid번째 행부터 마지막 행까지 문자열을 합친 후, 이 문자열(tmp)가 이미 set에 존재하는지 찾습니다(s.find(tmp)). 
만약 tmp가 이미 set에 존재한다면(s.find(tmp) != s.end()), 그것은 해당 범위에서 중복된 문자열이 있다는 것을 의미합니다.

따라서, 이 경우 'check' 변수를 false로 설정하고 for 반복문을 종료합니다. 
이렇게 해서 'check' 변수가 false인 경우 end 값을 mid - 1로 설정하여 다음 탐색 범위를 줄입니다.

반대로 'tmp'가 'set'에 없다면 (s.find(tmp) == s.end()), 
그것은 해당 범위에서 중복된 문자열이 없다는 것을 의미하므로, 
'tmp'를 set에 추가합니다(s.insert(tmp)).

따라서 위 코드에서 set의 사용은 주어진 조건 내에서 중복되는 문자열의 존재 여부를 빠르게 확인하기 위한 것입니다.
*/




/*
ios_base::sync_with_stdio(false);와 cin.tie(0);는 C++의 입출력 성능을 향상시키기 위해 사용되는 코드입니다.

C++의 iostream 라이브러리는 C 스타일의 입출력 함수(printf, scanf)보다 느린 속도로 동작할 수 있습니다. 
이는 C++의 입출력 스트림과 C 표준 입출력 버퍼 사이에 동기화 작업을 수행하기 때문입니다. 
이러한 동기화 작업은 다양한 언어 간 상호 운용성을 제공하고, 예상치 못한 결과를 방지하기 위해 필요합니다.

하지만, 많은 경우에는 이러한 동기화 작업이 필요하지 않고, 속도가 중요한 상황에서는 성능 저하를 가져올 수 있습니다. 
따라서, ios_base::sync_with_stdio(false);를 호출하여 C++의 입출력 스트림과 C 표준 입출력 버퍼 간의 동기화를 해제할 수 있습니다. 
이렇게 하면 입력 및 출력 작업이 좀 더 빠르게 처리될 수 있습니다.

또한, cin.tie(0);은 cin 객체와 cout 객체를 연결하는 연산자 결합도를 해제하는 역할을 합니다. 
기본적으로 cin.tie(&cout)로 설정되어 있어서 입력 작업(cin)과 출력 작업(cout)이 서로 연결되어 있는데, 
이로 인해 출력 버퍼가 비워질 때마다 입력 버퍼도 함께 비워지게 됩니다. 
그러나 실제로 입력과 출력이 병렬적으로 진행되지 않아야 하는 경우에는 연결을 해제하여 성능 향상을 기대할 수 있습니다.

따라서, 위 코드들은 일반적인 경우보다 입출력 속도가 중요하거나 병렬 실행이 필요한 상황에서 사용될 수 있습니다. 
하지만 주의해야 할 점은 이러한 최적화 코드들은 프로그램 전체에 영향을 미칠 수 있다는 것입니다. 
따라서 다른 I/O 함수나 라이브러리와 함께 사용할 때 문제가 발생하지 않도록 주의해야 합니다.
*/